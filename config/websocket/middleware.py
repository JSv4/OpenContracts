import logging
from typing import Any, Dict, Union
from urllib.parse import parse_qsl

from channels.db import database_sync_to_async
from channels.middleware import BaseMiddleware
from django.contrib.auth.models import AnonymousUser
from django.http import HttpRequest

from graphql_jwt.exceptions import JSONWebTokenError
from graphql_jwt.utils import get_payload, get_user_by_payload

logger = logging.getLogger(__name__)

class GraphQLJWTTokenAuthMiddleware(BaseMiddleware):
    """
    Middleware for Django Channels that authenticates incoming WebSocket connections
    using a JWT token generated by graphql_jwt.

    The token is expected to be found as a 'token' query parameter in the WebSocket
    connection URL. This class mirrors the decoding and payload checks found in
    graphql_jwt's utilities, ensuring that only tokens properly issued by graphql_jwt
    are considered valid.
    """

    def __init__(self, app: Any) -> None:
        """
        Initialize the GraphQLJWTTokenAuthMiddleware with the underlying ASGI application.

        :param app: The ASGI application to wrap.
        """
        super().__init__(app)

    @database_sync_to_async
    def _authenticate_token(self, token: str) -> Union[Any, AnonymousUser]:
        """
        Authenticates a JWT token by verifying its payload using the graphql_jwt utility
        functions. If the payload yields a valid user, return that user object, otherwise
        return AnonymousUser or raise an error.

        :param token: The raw JWT token string to validate.
        :return: An authenticated user object if valid; otherwise raises an error.
        """
        try:
            # The get_payload function validates and decodes the token.
            # If it's expired or invalid, it will raise an error from graphql_jwt.
            payload = get_payload(token)

            # Retrieve the user using the token's payload
            user = get_user_by_payload(payload)
            if not user:
                raise JSONWebTokenError("Unable to retrieve user from token payload.")
            return user
        except Exception as e:
            logger.error(f"Token authentication failed: {e}")
            raise JSONWebTokenError("Invalid or expired token.") from e

    async def __call__(self, scope: Dict[str, Any], receive: Any, send: Any) -> Any:
        """
        Extracts the token from the WebSocket connection's query string, attempts
        authentication, and sets scope["user"] accordingly.

        If authentication fails, scope["error_msg"] will be populated with an error message
        and the WebSocket will be closed.

        :param scope: The ASGI scope dictionary for the current connection.
        :param receive: The receive callable.
        :param send: The send callable.
        :return: The result of the next application in the chain.
        """
        query_string_params = dict(parse_qsl(scope["query_string"].decode("utf-8")))
        token = query_string_params.get("token")

        if token is None:
            # Token not provided, set AnonymousUser or close connection
            scope["user"] = AnonymousUser()
            scope["error_msg"] = "Token not provided."
            await send({"type": "websocket.close", "code": 1000, "reason": "No token."})
            return await self.app(scope, receive, send)

        try:
            # Attempt to authenticate token
            scope["user"] = await self._authenticate_token(token)
        except JSONWebTokenError as e:
            # If token authentication fails, close the websocket.
            scope["user"] = AnonymousUser()
            scope["error_msg"] = str(e)
            await send({"type": "websocket.close", "code": 1000, "reason": "Invalid token."})

        return await self.app(scope, receive, send)
