from __future__ import annotations

import json
import vcr
import logging
from typing import Any
from urllib.parse import quote
from django.conf import settings

from channels.testing import WebsocketCommunicator
from graphql_relay import to_global_id
from django.test.utils import override_settings

from opencontractserver.llms.types import AgentFramework
from opencontractserver.tests.base import WebsocketFixtureBaseTestCase

logger = logging.getLogger(__name__)


@override_settings(USE_AUTH0=False)
class DocumentConversationWebsocketTestCase(WebsocketFixtureBaseTestCase):
    """
    End-to-end websocket test for the refactored DocumentQueryConsumer.

    The LLM layer is patched so the test never touches real network / GPU
    resources.  We assert that the consumer still emits the four message
    types the front-end relies on and that the message-ids remain consistent
    throughout the stream.
    """

    expected_responses = {
        str(AgentFramework.LLAMA_INDEX): """# Summary of USC Title 1 - Chapter 1

This is an autogenerated summary for the document. Please replace it with real content if needed.
        """,
        str(AgentFramework.PYDANTIC_AI): """It seems you might be looking for a live stream or multimedia content, but unfortunately, I can't provide streaming services. However, I can offer you a detailed summary or information about 'USC Title 1 - Chapter 1' if you're interested. Let me know how I can assist you!"""
    }

    # ------------------------------------------------------------------
    # Helper that performs the websocket round-trip + assertions
    # ------------------------------------------------------------------
    async def _assert_streaming_flow(self) -> None:
        """
        Connect, send a query, and verify ASYNC_START → ASYNC_CONTENT →
        ASYNC_FINISH message sequence with stable ``message_id``.
        """

        # ------------------------------------------------------------------
        # 2.  Build websocket path (same pattern the real front-end uses)
        # ------------------------------------------------------------------
        graphql_id = to_global_id("DocumentType", self.doc.id)
        encoded_graphql_id = quote(graphql_id)
        encoded_corpus_id = quote(to_global_id("CorpusType", self.corpus.id))

        # Valid JWT token provided by the fixture base-class
        communicator = WebsocketCommunicator(
            self.application,
            f"ws/document/{encoded_graphql_id}/query/corpus/{encoded_corpus_id}/?token={self.token}",
        )

        connected, _ = await communicator.connect()
        self.assertTrue(connected, "WebSocket should establish successfully.")

        # ------------------------------------------------------------------
        # 3.  Send a user query
        # ------------------------------------------------------------------
        await communicator.send_to(
            json.dumps({"query": "Please stream something"})
        )

        # ------------------------------------------------------------------
        # 4.  Collect messages until we hit ASYNC_FINISH
        # ------------------------------------------------------------------
        received: list[dict[str, Any]] = []

        while True:
            try:
                msg = await communicator.receive_from(timeout=15)
            except Exception:
                self.fail("Timed-out waiting for websocket messages")

            payload = json.loads(msg)
            logger.debug("payload=%s", payload)
            received.append(payload)

            if payload.get("type") == "ASYNC_FINISH":
                break

        # ------------------------------------------------------------------
        # 5.  Assertions
        # ------------------------------------------------------------------
        self.assertGreaterEqual(
            len(received), 3,  # start + ≥1 content + finish
            "Consumer should emit at least START, one CONTENT, FINISH.",
        )

        # Types in chronological order
        self.assertEqual(received[0]["type"], "ASYNC_START")
        self.assertEqual(received[-1]["type"], "ASYNC_FINISH")

        # There must be one or more content messages in between
        content_msgs = [m for m in received if m["type"] == "ASYNC_CONTENT"]
        self.assertTrue(content_msgs, "At least one ASYNC_CONTENT expected.")
        
        # Extract content from each message and join into a single string
        full_text = "".join(msg["content"] for msg in content_msgs)

        # ------------------------------------------------------------------
        #  Expected content depends on the active framework
        # ------------------------------------------------------------------
        current_framework = str(
            getattr(settings, "LLMS_DOCUMENT_AGENT_FRAMEWORK", "llama_index")
        )
        logger.info("current_framework=%s", current_framework)
        logger.info("full_text=%s", full_text)
        
        expected_text = self.expected_responses.get(current_framework, "")

        if expected_text:
            # Exact match required when we have a deterministic expectation
            self.assertEqual(
                full_text.strip(),
                expected_text.strip(),
                f"Unexpected assistant output for framework '{current_framework}'.",
            )
        else:
            # Fallback: just ensure we received *something* non-empty
            self.assertTrue(
                full_text.strip(),
                "Assistant response should not be empty.",
            )
        
        # Message-id must stay constant across the whole stream
        start_msg_id = received[0]["data"]["message_id"]
        self.assertTrue(start_msg_id, "START message must contain a message_id.")

        for msg in received[1:]:
            if "data" in msg and "message_id" in msg["data"]:
                self.assertEqual(
                    msg["data"]["message_id"],
                    start_msg_id,
                    "message_id must remain constant for the full assistant message.",
                )

        # ------------------------------------------------------------------
        # 6.  Cleanup
        # ------------------------------------------------------------------
        await communicator.disconnect()

    # ------------------------------------------------------------------
    # Negative-path helpers
    # ------------------------------------------------------------------
    async def _assert_invalid_token(self) -> None:
        """Connection should be rejected (code 4000) when the JWT is invalid."""
        graphql_id = to_global_id("DocumentType", self.doc.id)
        encoded_graphql_id = quote(graphql_id)
        encoded_corpus_id = quote(to_global_id("CorpusType", self.corpus.id))

        communicator = WebsocketCommunicator(
            self.application,
            f"ws/document/{encoded_graphql_id}/query/"
            f"corpus/{encoded_corpus_id}/?token=not_a_real_token",
        )
        connected, close_code = await communicator.connect()
        self.assertFalse(connected)
        self.assertEqual(close_code, 4000)

    async def _assert_missing_token(self) -> None:
        """Omitting the token entirely must also yield close 4000."""
        graphql_id = to_global_id("DocumentType", self.doc.id)
        encoded_graphql_id = quote(graphql_id)
        encoded_corpus_id = quote(to_global_id("CorpusType", self.corpus.id))

        communicator = WebsocketCommunicator(
            self.application,
            f"ws/document/{encoded_graphql_id}/query/"
            f"corpus/{encoded_corpus_id}/",
        )
        connected, close_code = await communicator.connect()
        self.assertFalse(connected)
        self.assertEqual(close_code, 4000)

    async def _assert_invalid_document(self) -> None:
        """
        A non-existent document ID should result in:
        • WebSocket *accepted*
        • Immediate `SYNC_CONTENT` error payload
        • Close code 4000
        """
        bad_doc_gid = to_global_id("DocumentType", 999_999)
        encoded_bad_doc = quote(bad_doc_gid)
        encoded_corpus_id = quote(to_global_id("CorpusType", self.corpus.id))

        communicator = WebsocketCommunicator(
            self.application,
            f"ws/document/{encoded_bad_doc}/query/"
            f"corpus/{encoded_corpus_id}/?token={self.token}",
        )
        connected, _ = await communicator.connect()
        self.assertTrue(connected)

        raw = await communicator.receive_from(timeout=5)
        payload = json.loads(raw)
        self.assertEqual(payload["type"], "SYNC_CONTENT")
        self.assertIn("error", payload["data"])
        self.assertEqual(payload["data"]["error"], "Requested Document not found.")

        # The consumer should now close the websocket with code 4000.
        close_event = await communicator.receive_output(timeout=15)
        self.assertEqual(close_event["type"], "websocket.close")
        self.assertEqual(close_event["code"], 4000)

        # Ensure the communicator is fully shut down
        await communicator.wait()

    # ------------------------------------------------------------------
    # Public test – executed for both possible default frameworks
    # ------------------------------------------------------------------
    @vcr.use_cassette(
        "fixtures/vcr_cassettes/test_document_conversation_ws.yaml",
        filter_headers=["authorization"],
    )
    async def test_streaming_flow__all_default_frameworks(self) -> None:
        """
        Run the streaming-flow assertions twice – once with the global
        defaults set to ``llama_index`` and once with ``pydantic_ai`` – to
        confirm that our *settings-based* default selection works identically
        for document-level conversations.
        """

        for framework in ("llama_index", "pydantic_ai"):
            with self.subTest(default_framework=framework):
                with override_settings(
                    LLMS_DEFAULT_AGENT_FRAMEWORK=framework,
                    LLMS_DOCUMENT_AGENT_FRAMEWORK=framework,
                    LLMS_CORPUS_AGENT_FRAMEWORK=framework,
                ):
                    await self._assert_streaming_flow()

    # ------------------------------------------------------------------
    # Negative-path public tests (framework-agnostic)
    # ------------------------------------------------------------------
    async def test_invalid_token(self) -> None:  # noqa: D401
        """Connection rejected with an **invalid** JWT token."""
        await self._assert_invalid_token()

    async def test_missing_token(self) -> None:  # noqa: D401
        """Connection rejected when **no** JWT token is supplied."""
        await self._assert_missing_token()

    async def test_invalid_document_id(self) -> None:  # noqa: D401
        """Proper SYNC_CONTENT error for a non-existent document ID."""
        await self._assert_invalid_document()
        