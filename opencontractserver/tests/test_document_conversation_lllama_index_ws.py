from __future__ import annotations

import json
import vcr
import logging
from types import SimpleNamespace
from typing import Any
from urllib.parse import quote

from channels.testing import WebsocketCommunicator
from graphql_relay import to_global_id
from unittest import mock
from unittest.mock import AsyncMock, MagicMock

from opencontractserver.tests.base import WebsocketFixtureBaseTestCase

logger = logging.getLogger(__name__)


class DocumentConversationWebsocketTestCase(WebsocketFixtureBaseTestCase):
    """
    End-to-end websocket test for the refactored DocumentQueryConsumer.

    The LLM layer is patched so the test never touches real network / GPU
    resources.  We assert that the consumer still emits the four message
    types the front-end relies on and that the message-ids remain consistent
    throughout the stream.
    """

    @vcr.use_cassette(
        "fixtures/vcr_cassettes/test_document_conversation_ws.yaml",
        filter_headers=["authorization"],
    )
    async def test_streaming_flow(
        self,
    ) -> None:
        """
        Connect, send a query, and verify ASYNC_START → ASYNC_CONTENT →
        ASYNC_FINISH message sequence.
        """

        # ------------------------------------------------------------------
        # 2.  Build websocket path (same pattern the real front-end uses)
        # ------------------------------------------------------------------
        graphql_id = to_global_id("DocumentType", self.doc.id)
        encoded_graphql_id = quote(graphql_id)
        encoded_corpus_id = quote(to_global_id("CorpusType", self.corpus.id))

        # Valid JWT token provided by the fixture base-class
        communicator = WebsocketCommunicator(
            self.application,
            f"ws/document/{encoded_graphql_id}/query/corpus/{encoded_corpus_id}/?token={self.token}",
        )

        connected, _ = await communicator.connect()
        self.assertTrue(connected, "WebSocket should establish successfully.")

        # ------------------------------------------------------------------
        # 3.  Send a user query
        # ------------------------------------------------------------------
        await communicator.send_to(
            json.dumps({"query": "Please stream something"})
        )

        # ------------------------------------------------------------------
        # 4.  Collect messages until we hit ASYNC_FINISH
        # ------------------------------------------------------------------
        received: list[dict[str, Any]] = []

        while True:
            try:
                msg = await communicator.receive_from(timeout=5)
            except Exception:
                self.fail("Timed-out waiting for websocket messages")

            payload = json.loads(msg)
            logger.debug("payload=%s", payload)
            received.append(payload)

            if payload.get("type") == "ASYNC_FINISH":
                break

        # ------------------------------------------------------------------
        # 5.  Assertions
        # ------------------------------------------------------------------
        self.assertGreaterEqual(
            len(received), 3,  # start + ≥1 content + finish
            "Consumer should emit at least START, one CONTENT, FINISH.",
        )

        # Types in chronological order
        self.assertEqual(received[0]["type"], "ASYNC_START")
        self.assertEqual(received[-1]["type"], "ASYNC_FINISH")

        # There must be one or more content messages in between
        content_msgs = [m for m in received if m["type"] == "ASYNC_CONTENT"]
        self.assertTrue(content_msgs, "At least one ASYNC_CONTENT expected.")
        
        # Extract content from each message and join into a single string
        full_text = "".join(msg["content"] for msg in content_msgs)
        self.assertEqual(full_text, """Here's a summary for the document titled **'Test Doc' (ID: 1)**:

### Summary
Autogenerated test summary – replace with real content if needed.

If you need more specific details or any other information, feel free to ask!""")
        
        # Message-id must stay constant across the whole stream
        start_msg_id = received[0]["data"]["message_id"]
        self.assertTrue(start_msg_id, "START message must contain a message_id.")

        for msg in received[1:]:
            if "data" in msg and "message_id" in msg["data"]:
                self.assertEqual(
                    msg["data"]["message_id"],
                    start_msg_id,
                    "message_id must remain constant for the full assistant message.",
                )

        # ------------------------------------------------------------------
        # 6.  Cleanup
        # ------------------------------------------------------------------
        await communicator.disconnect()
        